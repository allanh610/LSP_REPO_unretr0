Compared to Assignment 2, Assignment 3’s code has had a dramatic shift in design philosophy from procedural to an object-oriented approach. The logic for A2’s code is monolithic, with the code being interwoven in one place and the main method being responsible for everything. Its job is to open files, read lines, parse strings, apply discounts, categorize prices, and write to a new file (transformed_products.csv). With A3’s new design, the logic is broken down into distinct components: CSVExtractor, ProductTransformer, and CSVLoader. These components are given only one job. CSVExtrator’s job is to extract data from a CSV file, ProductTransformer is used to apply business rules to a list of products, and CSVLoader loads the list of products into a new CSV file, in this case transformed_products.csv. Another difference is that in A2, all the steps were dependent on each other within the same method. In A3, components are independent and makes the system far more flexible and easier to maintain. When it comes to data, A2’s data was handled as primitive types within the main method, with no formal structure representing a "product." A3’s code uses a new Product record that creates an immutable data structure that passes around Product objects instead of passing around arrays of strings. Testing using A3’s code is also easier as it creates a test for just the ProductTransformer class. In that test, it can create a sample List<Product> in memory, pass it to the transform() method, and assert that the returned list has the correct values. A3 is more object-oriented than A2 because it creates a system of distinct classes—each with a single, clear responsibility. It hides the complex implementation details within each object, allowing the main method to read as a simple, high-level summary of the ETL process. The system is also much more robust, readable, and flexible for future changes. I used the OO ideas of Class, Object, Encapsulation, and Abstraction for A3. The blueprints like ETLPipeline, CSVExtractor, and the Product record are used to create specific instances, such as the extractor and transformer objects in the main method, bundling the complex file-reading logic within the CSVExtractor object and hiding it from the main orchestrator, which only needs to call the simple extract() method. This leads to abstraction, as the main method presents a simplified, high-level view of the ETL process within the output. In order to confirm A3 compiled and ran the same as A2, I ran it using the same test cases as before: the normal input with parameters ProductID, Name, Price, and Category, an empty input, and a missing input file. During testing, I compared the output of A3 with the output of A2, and A3 successfully output the exact same data as A2 in all three tests.